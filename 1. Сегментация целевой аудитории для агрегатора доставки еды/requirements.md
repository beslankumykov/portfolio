Необходимо построить три метрики для каждого пользователя:
- Фактор Recency измеряется по последнему заказу. Необходимо найти последний orders.order_ts по каждому user_id.
- Фактор Frequency оценивается по количеству заказов. Необходимо посчитать количество orders.order_id по каждому user_id.
- Фактор Monetary оценивается по потраченной сумме. Необходимо посчитать сумму значений orders.payment по каждому user_id.

Глубина данных - все данные, начиная с 2021-го года.

Расположение витрины данных, промежуточных таблиц и представлений, отображающих данные источника - схема analysis.

Все метрики должны быть построены на закрытых заказах, то есть, значение в поле status в таблице orders должно соответствовать значению в поле id в таблице orderstatuses, у которого key = 'Closed'. 

Дополнительно, при расчете каждой метрики потребуется соединение с таблицей users по полю id, чтобы при ранжировании учесть тех клиентов, у которых не было закрытых заказов. В таблице orders этому полю соответстует поле user_id.


План построения витрины для RFM-анализа:

1. В requirements.md описать необходимые поля.
2. В data_quality.md указать информацию о качестве данных и инструментах для обеспечения качества в источнике.
3. Создать представления в схеме analysis на основе оперативных данных в схеме production без преобразований. Скрипты поместить в файл views.sql. 
4. Создать таблицу analysis.dm_rfm_segments, которая будет являться витриной данных. Скрипт поместить в файл datamart_ddl.sql.
5. Создать промежуточные таблицы под каждый показатель в схеме analysis с названиями tmp_rfm_recency, tmp_rfm_frequency, tmp_rfm_monetary_value.
6. Написать sql-запросы для заполнения каждой из промежуточных таблиц. Скрипты поместить в файлы tmp_rfm_recency.sql, tmp_rfm_frequency.sql, analysis.tmp_rfm_monetary_value. При написании скриптов учесть, что метрики должны быть построены на успешно выполненных заказах (статус Closed) и на данных с начала 2021 года.
7. Написать sql-запрос для заполнения витрины analysis.dm_rfm_segments на основе ранее подготовленных таблиц. Скрипт поместить в файл datamart_query.sql.
8. Скопировать в файл datamart_query.sql первые десять строк из полученной таблицы, отсортированные по user_id.
9. Перестроить представление analysis.Orders так, чтобы поле status соответствовало последнему по времени статусу из таблицы production.OrderStatusLog. Скрипт поместить в файл orders_view.sql.